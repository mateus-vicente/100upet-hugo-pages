---
title: "Allpix Squared 2.0 Released"
date: 2021-06-10T15:42:10+02:00
draft: true
---

We are happy to announce the second major release **{{% allpix %}}, version 2.0.0**.
This version contains XXX commits over thre previous patch release 1.6.2.

It features a major rework of the framework core, introducing an efficient multithreading functionality including full reproducibility.
In addition, a large number of features as well as changes to the core and the CI have been implemented.

The release is available as Docker image, CVMFS installation, binary tarball and source code from the [repository](https://gitlab.cern.ch/allpix-squared/allpix-squared/).

The release benefits from the work of XXX contributors, of which XXX are first-time contributors.
Furthermore it is to a substantial part the result achieved by two Google Summer of Code students.

{{% allpix %}} has been extended by the following features and changes:
<!--more-->

## Multithreading

The biggest new feature is arguably the availability of full, event-based multithreading.
With this, the simulation can make full use of all available CPU resources and can significantly speed up the simulation.
The feature has been initially developed by two Google Summer of Code students, Viktor Sonesten and Mohamed Moanis Ali, and has been completed with lots of rework in the first few months of 2021.
While the initial code was in place relatively quickly, quite some obstacles have been encountered on the way to a stable version.

### Event Parallelisation

In versions 1.x, {{% allpix %}} already had the option to process

### Event-based Seeding

One of the corner stones of Monte Carlo simulations is reproducibility.
Also with multithreading, {{% allpix %}} guarantees strong reproducibility, meaning that a simulation can be fully reproduced when starting the program with the same configuration and the same starting seeds for the pseudo-random number generation.
Especially in multithreaded environments, this places stringent requirements on the internal workings of the code base and the way, seeds are distributed and random numbers are used by the different parts.
A common approach, also implemented in {{% allpix %}} is event-based seeding.
For this, every event receives a seed from a central pseudo-random number generator (PRNG) upon its creation. This seed subsequently is used to set the initial state of a PRNG to be used throughout the lifetime of this event.
in order to keep the memory footprint as low as possible, {{% allpix %}} does not allocate these PRNGs per event, but only per worker thread and seeds them whenever a new event is processed on the respective thread.
in order to allow interruption of event processing and resumption at a later point in time, the state of the PRNG is stored whenever the event processing is halted, e.g. for buffering as described below, and is loaded again when the event is restarted.

### Input/Output Module and Event Sequence

In order to create fully bit-compatible output files and to guarantee the same input to the simulation, matched to the same event seeds, some modules require to process events in their predefined sequence.
This means the framework core has to take care of distributing workload accordingly an to buffer events which are not due for processing in the relevant modules, and to avoid data races.
{{% allpix %}} provides a new class of modules, dubbed `SequentialModule`, for this purpose.
Modules deriving from this class have the guarantee to receive events for processing in their natural sequence.
The central thread pool holds a priority queue for partially processed events which are waiting to be further processed by a sequential module.
This allows to temporarily buffer these events such that the workers can occupy themselves with another event, leading to a very efficient usage of available resources.
An almost linear increase in event generation frequency with the number of worker threads has been observed for up to the tested maximum of 96 CPU cores that were available, despite the presence of SequentialModules in the simulation chain.

{{< figure src="/img/rate.png" caption="Event generation rate as function of used worker threads for a reference simulation" >}}

Sequential modules can waive the sequence requirement at run time if they have been configured in a way that strict order in event processing is not required by the user.


### Interface to Geant4

The run managers provided by the Geant4 framework for multithreaded simulations start and manage their own threads, a solution that does not integrate with the {{% allpix %}} framework.
It was therefore necessary to write our own implementation of run managers, both for single- and multithreaded execution of the simulation in order to be able to control the worker threads, but also to re-seed the Geant4 pseudo-random number generators with the event seeds obtained from the {{% allpix %}} core.
In the end, the solution implemented is quite sleek and has less overhead than the initial Geant4 interface used up to version 1.6.2

Over the course of these renovations, we have also overhauled the way Geant4's informational messages and error codes are transmitted and displayed.
It is now possible to redirect the Geant4 output to any level of the {{% allpix %}} logger and therefore to properly see and log e.g. exceptions from problematic events generated.
This can be done by setting the relevant configuration keys in the `GeometryBuilderGeant4` module:

```toml
[GeometryBuilderGeant4]
# Target logging level for Geant4 messages from the G4cerr (error) stream:
log_level_g4cerr = WARNING
# Target logging level for Geant4 messages from the G4cout stream:
log_level_g4cout = TRACE
```

### Framework Core

#### C++17

The requirement on the C++ standard was increased from `C++14` to `C++17`.
With this, several workarounds were removed and replaced by simpler `C++17` specific methods.

#### Boost Random Number Generator

As one piece of the puzzle of the full reproducibility of simulations, the C++ STL random number generator was replaced by the implementation provided with the Boost.Random library.
This implementation is platform independent and therefore enables reproducibility across all platforms.

This implicates a dependency of {{% allpix %}} on Boost.Random, which is available for all common platforms.

#### Unused Configuration Keys

The user is now made aware of unused configuration keys, hinting at unintended configuration scenarios or potential typos in the simulation's main configuration file.


### Charge Carrier Recombination

All available propagation modules, `GenericPropagation`, `ProjectionPropagation` and `TransientPropagation` have been extended by the functionality of charge carrier recombination, where the lifetime of any charge carrier is derived from the doping concentration of the sensor.

For the determination of the charge carrier lifetime, three models have been implemented, to be selected by the user: the Shockley-Read-Hall model, the Auger model, which applies to minority charge carriers only, and a combination of these two, for which the minority charge carrier lifetime follows the Auger model and majority charge carriers follow the Shockley-Read-Hall model.

At every step of the charge carrier propagation, the survival probability of a charge carrier is evaluated by comparing the duration of the time step to the lifetime provided by the above mentioned models.


#### New Module: DopingProfileReader

A new module called `DopingProfileReader` has been added, allowing the user to define the position dependent doping concentration of the sensor.

The doping profile can be provided in three ways:
 * A constant doping concentration can be defined for the entire sensor volume.
 * Several regions of different doping concentrations can be defined via a segmentation along the sensor depth.
 * A three-dimensional map can be parsed from files in the APF or INIT formats, which can also be used for the electric field and the weighting potential maps.

The use of this module is required for the simulation of a charge carrier recombination.


### Front-End saturation in `DefaultDigitizer`

A very simple front-end saturation simulation has been added to the `DefaultDigitizer`.

With this feature enabled, pixel charge values above a configurable saturation limit are replaced by a value drawn from a Gaussian distribution with a mean at the saturation limit and a configurable width.


### Mobility Models

Additional mobility models have been added to the framework.
{{% allpix %}} now comprises the following mobility models:
 * Jacoboni-Canali model: previously used model and enabled by default.
 * Canali model: differs from the above in a single parameter.
 * Hamburg model: based on measurement on drift velocities.
 * Hamburg high-field model: differs from the above in the parameters, validated for electric fields of above 2.5~kV/cm.

The user can select the desired mobility model from within the charge carrier propagation module configuration, while the previously used Jacoboni-Canali model remains the default option.


### Physics Models

Several physics models have been disentangled from the simulation modules.
For this, the respective methods to determine model parameters have been extracted from the individual module and implemented as separate classes.
This avoids duplication of code and entails a more coherent use of these models throughout the different modules, for which the individual models can be enabled via a parameter in the corresponding configuration section.

Currently, charge carrier mobility and lifetime models are provided.


### Analytic Electric Fields

More complex, analytic electric fields can be defined by the module `ElectricFieldReader`.
In addition to the three-dimensional map and the analytic linear and constant electric field profiles, the user can now choose a parabolic parametrisation, as well as provide a custom analytic parametrisation.
The latter features either one- or three-dimensional electric field vectors provided in ROOT's TF1 syntax.


### New Example: EUDET-type beam telescope + DUT


### Model XXX in `CSADigitizer`
!455

### Continuous Integration

#### Module Tests

The module test configurations have been moved into the respective module directories, which should provide a better overview over which module an individual test is probing.

#### Linting & Formatting for `CMake`

New formatting rules have been introduced for `CMake` files.
Formatting tests have been introduced within the Continuous Integration.

### Additional Features & Changes

 * Passive Materials:
   * PPO foam added
   * Fix in definition of cellulose
   * Added option to define the object colour for the visualisation
 * `PulseTransfer`
   * Add maps of induced charge per event
 * CI:
   * Tests now fail in case of `WARNING`, `ERROR` or `FATAL` log messages
   * Update to LCG version LCG_99
   * Update to Geant4 10.7
 * `DepositionReader`:
   * Fix generation of `MCParticle` objects
   * Add module tests based on the python tool for the generation of deposits
 * `CSADigitizer`:
   * Fix global time calculation
   * Fix handling of uninitialised pulses
 * Tools:
   * `MeshConverter`: Cache parsed fields for more efficient conversion
   * `MeshPlotter`: Fix slicing for two-dimensional fields
 * `DepositionGeant4`:
   * Add possibility for uniform beam profile
   * Fix beam divergence in case of beam direction not pointing along the z-axis
 * Core:
   * Introducing `enum` reflection for module configuration parameters
   * Catch `SIGABRT` signal used by Geant4 in case of exceptions
 * `DepositionPointCharge`:
   * Make number of charge carriers created per unit length configurable
 * `TransientPropagation`:
   * Fix double counting effect of induced current in case of propagations around the border of a pixel cell
 * `EelctricFieldReader`:
   * Fix missing of z scale for field representations
   * Warn at unphyiscally high electric fields
 * 
